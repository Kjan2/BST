

#include <utility>
#include <iostream>
/*!
    Имплементация бинарного дерева поиска
    Допускается дублирование ключей (аналог multimap)
*/
template <typename Key = int, typename Value = int>
class BinarySearchTree
{
    struct Node
    {
        Node(Key key, 
             Value value, 
             Node* parent = nullptr, 
             Node* left = nullptr, 
             Node* right = nullptr)
        {
            keyValuePair = std::make_pair(key, value);
        }

        std::pair<Key, Value> keyValuePair;
        Node* parent = nullptr;
        Node* left = nullptr;
        Node* right = nullptr;
    };

public:
    //! Конструктор по умолчанию
    BinarySearchTree() = default;
    
    //! Копирование
    explicit BinarySearchTree(const BinarySearchTree& other)
    {
    }
    BinarySearchTree& operator=(const BinarySearchTree& other);
    //! Перемещение
    explicit BinarySearchTree(BinarySearchTree&& other) noexcept;
    BinarySearchTree& operator=(BinarySearchTree&& other) noexcept;

    //! Деструктор
    ~BinarySearchTree()
    {
        destruct(_root);
    }

    /*!
        Итератор бинарного дерева поиска

        Обходит дерево последовательно от меньшего ключа к большему 
    */
    class Iterator
    {
    public:
        explicit Iterator(Node* node) : _node(node)
        {

        }

        std::pair<Key, Value>& operator*()
        {
            return _node->keyValuePair;
        }

        const std::pair<Key, Value>& operator*() const
        {
            return _node->keyValuePair;
        }

        std::pair<Key, Value>* operator->()
        {
            return &(_node->keyValuePair);
        }

        const std::pair<Key, Value>* operator->() const
        {
            return &(_node->keyValuePair);
        }

        Iterator operator++()
        {
            if (_node->right != nullptr)
            {
                _node = _node->right;

                while (_node->left != nullptr)
                {
                    _node = _node->left;
                }

                return Iterator(_node);
            }

            
            Node* y = _node->parent;
            
            while ((y != nullptr) && (_node == y->right))
            {
                _node = y;
                y = _node->parent; 
            }

            _node = y;

            return Iterator(_node);
        }

        Iterator operator++(int)
        {
            Iterator it(*this);
            ++(*this);
            return it;
        }

        Iterator operator--()
        {
            if (_node->left != nullptr)
            {
                _node = _node->left;

                while (_node->right != nullptr)
                {
                    _node = _node->right;
                }

                return Iterator(_node);
            }

            
            Node* y = _node->parent;

            while ((y != nullptr) && (_node == y->left))
            {
                _node = y;
                y = _node->parent; 
            }

            _node = y;

            return Iterator(_node);

        }
        Iterator operator--(int)
        {
            Iterator it(*this);
            --(*this);
            return it;
        }

        bool operator==(const Iterator& other) const;
        bool operator!=(const Iterator& other) const;

    private:
        Node* _node;
    };

    /*!
        Константный итератор
    */
    class ConstIterator
    {
    public:
        explicit ConstIterator(const Node* node) : _node(node)
        {

        }

        const std::pair<Key, Value>& operator*() const
        {
            return _node->keyValuePair;  
        }

        const std::pair<Key, Value>* operator->() const
        {
            return &(_node->keyValuePair);
        }

        ConstIterator operator++()
        {
            if (_node->right != nullptr)
            {
                _node = _node->right;

                while (_node->left != nullptr)
                {
                    _node = _node->left;
                }

                return ConstIterator(_node);
            }

            
            Node* y = _node->parent;
            
            while ((y != nullptr) && (_node == y->right))
            {
                _node = y;
                y = _node->parent; 
            }

            _node = y;

            return ConstIterator(_node);

        }

        ConstIterator operator++(int)
        {
            ConstIterator it(*this);
            ++(*this);
            return it;
        }

        ConstIterator operator--()
        {
            if (_node->left != nullptr)
            {
                _node = _node->left;

                while (_node->right != nullptr)
                {
                    _node = _node->right;
                }

                return ConstIterator(_node);
            }

            
            Node* y = _node->parent;

            while ((y != nullptr) && (_node == y->left))
            {
                _node = y;
                y = _node->parent; 
            }

            _node = y;

            return ConstIterator(_node);
        }
        ConstIterator operator--(int)
        {
            ConstIterator it(*this);
            --(*this);
            return it;
        }

        bool operator==(const Iterator& other) const
        {
            return (this->_node == other._node); 
        }
        bool operator!=(const Iterator& other) const
        {
            return !(this->_node == other._node);
        }

    private:
        const Node* _node;
    };

    // вставить элемент с ключем key и значением value
    void insert(const Key& key, const Value& value)
    {
        _size++;

        Node* insertNode = new Node(key, value);
        Node* y = nullptr;
        Node* x = _root;
        while (x != nullptr)
        {
            y = x;
            if (insertNode->keyValuePair.first < x->keyValuePair.first)
            {
                x = x->left;
            }

            else
            {
                x = x->right;
            }
        }

        insertNode->parent = y;

        if (y == nullptr)
        {
            _root = insertNode;
        }
        else
        {
            if (insertNode->keyValuePair.first < y->keyValuePair.first)
            {
                y->left = insertNode;
            }
            else
            {
                y->right = insertNode;
            }

        }
    }

    // удалить все элементы с ключем key
    void erase(const Key& key);

    // найти первый элемент в дереве, равный ключу key
    ConstIterator cfind(const Key& key) const
    {
        return ConstIterator(find(_root, key));
    }
    Iterator find(const Key& key)
    {
        return Iterator(find(_root, key));
    }

    // найти все элементы, у которых ключ равен key
    // первый итератор пары - первый элемент в дереве, равный key
    // второй итератор пары - первый элемент в дереве больший, чем key
    // [pair.first, pair.second) - полуинтервал, содержащий все элементы с ключем key
    std::pair<Iterator, Iterator> equalRange(const Key& key);
    std::pair<ConstIterator, ConstIterator> equalRange(const Key& key) const;

    // получить итератор на минимальное значение в дереве
    ConstIterator min(const Key& key) const
    {
 
    }
    // получить итератор на максимальное значение в дереве
    ConstIterator max(const Key& key) const
    {

    }

    Iterator begin()
    {
        Node* curr = _root;

        while (curr->left != nullptr)
        {
            curr = curr->left;
        }

        return Iterator(curr);
    }

    Iterator end()
    {
        Node* curr = _root;

        while (curr->right != nullptr)
        {
            curr = curr->right;
        }

        return Iterator(curr);
    }

    ConstIterator cbegin() const
    {
        Node* curr = _root;

        while (curr->left != nullptr)
        {
            curr = curr->left;
        }

        return ConstIterator(curr);
    }
    ConstIterator cend() const
    {
        Node* curr = _root;

        while (curr->right != nullptr)
        {
            curr = curr->right;
        }

        return ConstIterator(curr);
    }

    Node* _root = nullptr; //!< корневой узел дерева
    size_t size() const
    {
        return _size;
    }
private:
    size_t _size = 0;
    //Node* _root = nullptr; //!< корневой узел дерева

    void destruct(Node* node)
    {
        if (node == nullptr)
        {
            return;
        }

        destruct(node->left);
        destruct(node->right);
        delete node;
        node = nullptr;
    }
    Node* find(Node* node, Key key)
    {
        if ((node == nullptr) || (_root->keyValuePair.first == key))
        {
            return node;
        }

        if (node->keyValuePair.first < key)
        {
            return find(node->right, key);
        }
        
        return find(node->left, key);
    }
};

